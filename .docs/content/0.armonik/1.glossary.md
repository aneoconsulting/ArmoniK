# Glossary

**Client:** User-developed software that communicates with the ArmoniK Control Plane to submit a list of tasks to be executed (by one or several workers). It also retrieves results and any error.

**Compute Plane:** Expression designating the set of compute pods, i.e. the pods running a Polling/Scheduling Agent + Worker pair within the Kubernetes cluster.

**Container:** A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. (see Docker (documentation)[https://www.docker.com/resources/what-container/])

**Control Plane:** Expression designating a set of applications (distributed in different pods) that maintain the Kubernetes cluster as well as communications between certain components (queue, Redis, MongoDB) and the *client*.

**Data dependency:** Input data for a given task that depends on another unique task. Data dependencies formalize dependencies between tasks.

**Data Plane:** Expression designating the set of software components running the various storage and database systems within ArmoniK.

**Kubernetes:** Kubernetes is an open source container orchestration engine for automating deployment, scaling, and management of containerized applications. The open source project is hosted by the Cloud Native Computing Foundation ((CNCF)[https://www.cncf.io/about]) (see Kubernetes (documentation)[https://kubernetes.io/docs/home/#:~:text=Kubernetes%20is%20an%20open%20source,and%20management%20of%20containerized%20applications.]).

**MongoDB:** MongoDB is a document database designed for ease of application development and scaling (see MongoDB (documentation)[https://www.mongodb.com/docs/manual/]).

**Node/NÅ“ud:** Kubernetes runs a workload by placing containers into Pods to run on Nodes. A node may be a virtual or physical machine, depending on the cluster. Each node is managed by the Kubernetes control plane and contains the services necessary to run Pods. (see Kubernetes (documentation)[https://kubernetes.io/docs/concepts/architecture/nodes/]). 

**Partition:** Logical segmentation of the Kubernetes cluster's pool of machines to distribute workloads according to usage.

**Payload:** Input data for a task that does not depend on any other task.

**Pod:** Pods are the smallest deployable units of computing that one can create and manage in Kubernetes. A Pod is a group of one or more containers, with shared storage and network resources, and a specification for how to run the containers. A Pod's contents are always co-located and co-scheduled, and run in a shared context. A Pod models an application-specific "logical host": it contains one or more application containers which are relatively tightly coupled (see Kubernetes (documentation)[https://kubernetes.io/docs/concepts/workloads/pods/]).

**Polling/Scheduling agent:** Containerized software cohabiting with a worker within a pod, running a specific algorithm to determine which tasks "its" worker (the one with which it shares the pod) should perform. It also manages all interactions between the worker and the databases (retrieving/saving data, creating new tasks, etc.). A polling/scheduling agent, like a worker, exists within a single partition.

**Redis:** Redis is an open source (BSD licensed), in-memory data structure store used as a database, cache, message broker, and streaming engine. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster (see Redis (documentation)[https://redis.io/docs/about/]). In ArmoniK, Redis is used as a key-value cache for tasks data (such as payloads and results).

**Session:** Logical abstraction of a period of time during which a *client* maintains communication with ArmoniK's Control Plane in order to submit tasks, retrieve results or observe cluster behavior.

**Submitter:** Containerized software in charge of submitting tasks, i.e. writing the corresponding data to the various databases (queue, Redis and MongoDB).

**Task:** Indivisible unit of computation taking one or several input data and outputting one or several results.

**Worker:** User-developed containerized software capable of performing one or several tasks depending on its implementation.  A worker can simply take input data and perform calculations on it to return a result. A worker can also submit new tasks that will be performed by different workers, other instances of itself or itself.
